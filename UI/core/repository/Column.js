// @flow
'use strict';

import {Check, If, React, Type, Record, Repository, Trigger, Utils, Dispatcher, Store} from "../core";
import {DataType} from "./Type";


export default class Column {

    type: ?DataType = null;
    key: ?string = null;
    name: ?string = null;
    subtitle: ?string = null;
    hint: ?string = null;
    description: ?string = null;
    /**  wartość zostanie wczytana na żądanie pobrania rekordu - zalecane dla dużych danych */
    onDemand: boolean = false;
    enumerate: ?() => Map | Object | Array = null;
    units: ?() => {} = null;
    readOnly: ?boolean = null;
    required: ?boolean = null;
    disabled: ?boolean = null;
    unique: ?boolean = null;
    min: ?number = null;
    max: ?number = null;
    regex: ?string = null;
    autoGenerated: ?boolean = null;
    trimmed: ?boolean = null;
    defaultValue: ?any = null;
    defaultUnit: ?[] = null; //domyślna jednostka [klucz, tekst, mnożnik]
    //ToDo: Parsowanie ze stringa
    textCasing: ?string = null; // określa formatowanie tekstu (uppercase/lowercase/capitalize)
    validator: ?(value: any) => void = null;

    sortable: ? boolean = null;
    sortOrder: ? boolean = null;
    filterable: ? boolean = null;
    searchable: ? boolean = null;
    hidden: ? boolean = null;
    compare: ?(a: ?any, b: ?any) => number = null;
    filter: ?(filter: ?any, cell: ?any) => boolean = null;
    foreign: ?() => Repository = null;

    constructor(config: (c: Column) => void) {
        Object.preventExtensions(this);
        Check.isFunction(config);
        config(this);

        Check.id(this.key);
        Check.nonEmptyString(this.name);

        if (!(this.type instanceof DataType))
            this.type = Type.get(this.type);

        if (this.trimmed === null && this.type.single === "string" && this.type !== Type.PASSWORD)
            this.trimmed = true;

        If.isString(this.type, t => this.type = Type.get(t));
        Check.instanceOf(this.type, [Type.DataType]);

        Check.nonEmptyString(this.key);
        Check.nonEmptyString(this.name);

        this.hint = this.hint || this.name;

        if (this.type.enumerate && !this.enumerate)
            this.enumerate = () => this.type.enumerate;

        if (this.enumerate && !If.isFunction(this.enumerate)) {
            const arr = this.enumerate instanceof Array;
            const map: Map = new Map();
            Utils.forEach(this.enumerate, (value, key) => {
                if (arr) {
                    key = value;
                    if (value instanceof Array) {
                        key = value[0];
                        value = If.isDefined(value[1]) ? value[1] : key;
                    }
                }
                map.set(key, value);
            });
            this.enumerate = () => map;
        }


        if (this.type.units && !this.units)
            this.units = () => this.type.units;

        If.isDefined(this.enumerate, e => Check.isFunction(e));
        If.isDefined(this.units, e => Check.isFunction(e));

        if (this.foreign)
            this.enumerate = () => Check.instanceOf(this.foreign(), [Repository]).displayMap;

        Utils.makeFinal(this);
    }

    parse(value: any): any {
        return this.type.parse(value);
    }


}

export const TEXT_CASING = {
    NONE: null,
    UPPERCASE: 'uppercase',
    LOWERCASE: 'lowercase',
    CAPITALIZE: 'capitalize'
};