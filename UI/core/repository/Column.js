// @flow
'use strict';

import {DEV_MODE} from "../core";
import {Check, Is, Utils} from "../$utils";
import {DataType} from "./Type";
import * as Type from "./Type";

//import {RepoError} from "./Repository";

export class ForeignConstraint {
    currentLocal: Column;
    currentForeign: ?Column;
    allowedLocal: ?Column;
    allowedForeign: ?Column;
    allowedValues: ?any[];
}

export class Foreign {
    repo: Repository; // zewnętrzne repozytorium
    column: Column;
    constraints: ForeignConstraint[] = [];
}


//ToDo: Miłosz: readOnly + !autoUpdate = konflikt
export default class Column {

    type: ?DataType = null;
    key: ?string = null;
    name: ?string = null;
    subtitle: ?string = null;
    hint: ?string = null;
    description: ?string = null;
    /**  wartość zostanie wczytana na żądanie pobrania rekordu - zalecane dla dużych danych */
    onDemand: boolean = false;
    enumerate: ?() => Map | Object | Array = null;
    /** Ikony poszczególnych pozycji enumeraty wyświetlane w trybie inline*/
    enumIcons: ?Object = null;
    enumStyles: ?Object = null;
    units: ?() => {} = null;
    readOnly: ?boolean = null;
    required: ?boolean = null;
    disabled: ?boolean = null;
    unique: ?boolean = null;
    min: ?number = null;
    max: ?number = null;
    regex: ?string = null;
    autoGenerated: ?boolean = null;
    trimmed: ?boolean = null;
    defaultValue: ?any = null;
    defaultUnit: ?[] = null; //domyślna jednostka [klucz, tekst, mnożnik]
    //ToDo: Parsowanie ze stringa
    textCasing: ?string = null; // określa formatowanie tekstu (uppercase/lowercase/capitalize)
    validator: ?(value: any) => void = null;

    sortable: ? boolean = null;
    sortOrder: ? boolean = null;
    filterable: ? boolean = null;
    searchable: ? boolean = null;
    hidden: ? boolean = null;
    compare: ?(a: ?any, b: ?any) => number = null;
    filter: ?(filter: ?any, cell: ?any) => boolean = null;
    foreign: ?Foreign = null;
    repository: ?Repository = null;

    constructor(config: (c: Column) => void) {

        Utils.lazyProvider(this, "foreign", value => processForeign(this, value));

        if (DEV_MODE)
            this["#instance"] = null;


        const overloaded = this.constructor !== Column.prototype.constructor;
        if (!overloaded)
            Object.preventExtensions(this);

        Check.isFunction(config);
        config(this);

        if (DEV_MODE)
            this["#instance"] = this.key;

        this._update();
    }

    _load(data: Object) {
        for (let name in this)
            if (data[name] !== undefined)
                this[name] = data[name];
        this._update();
    }

    _update() {

        Check.id(this.key);
        Check.nonEmptyString(this.name, new Error("Nazwa kolumny " + this.key + " nie może być pusta"));

        if (!(this.type instanceof DataType))
            this.type = Type.get(this.type);

        if (this.trimmed === null && this.type.single === "string" && this.type !== Type.PASSWORD)
            this.trimmed = true;

        Is.string(this.type, t => this.type = Type.get(t));
        Check.instanceOf(this.type, [DataType]);

        Check.nonEmptyString(this.key);
        Check.nonEmptyString(this.name);

        this.hint = this.hint || this.name;
        //
        // if (Is.string(this.foreign)) {
        //     const foreignRepoKey = this.foreign;
        //     this.foreign = () => Repository.get(foreignRepoKey, true);
        // }

        if (!this.enumerate && this.type.enumerate)
            this.enumerate = () => this.type.enumerate;

        this.enumIcons = this.enumIcons || this.type.enumIcons;
        this.enumStyles = this.enumStyles || this.type.enumStyles;

        if (this.enumerate && !Is.func(this.enumerate)) {
            const arr = this.enumerate instanceof Array;
            const map: Map = new Map();
            Utils.forEach(this.enumerate, (value, key) => {
                if (arr) {
                    key = value;
                    if (value instanceof Array) {
                        key = value[0];
                        value = Is.defined(value[1]) ? value[1] : key;
                    }
                }


                map.set(this.type.parse(key), value);
            });
            this.enumerate = () => map;
        }


        if (this.type.units && !this.units)
            this.units = () => this.type.units;

        Is.defined(this.enumerate, e => Check.isFunction(e));
        Is.defined(this.units, e => Check.isFunction(e));

    }

    parse(value: any): any {
        return this.type.parse(value);
    }


}

function processForeign(col: Column, value: any): Foreign {

    const Repository = require("./Repository").default;

    if (!Is.defined(value) || value instanceof Foreign)
        return value;


    const f: Foreign = new Foreign();

    if (Is.func(value)) {
        f.repo = Check.instanceOf(value(), [Repository]);
        f.column = f.repo.primaryKeyColumn;
        return f;
    }

    if (Is.string(value)) {
        const items = (value: string).split(".");
        f.repo = Repository.get(items[0], true);
        f.column = items[1] ? f.repo.getColumn(items[1]) : f.repo.primaryKeyColumn;
        return f;
    }

    f.repo = Repository.get(value.repository, true);
    f.column = value.column ? Is.string(value.column, c => f.repo.getColumn(c, true), c => Check.instanceOf(c, [Column]))
        : f.repo.primaryKeyColumn;

    function getColumn(value: string) {
        const RepoError = require("./Repository").RepoError;

        const items: string[] = Check.isString(value).split(".");
        const repo: Repository = items[0] === "this" ? col.repository : Repository.get(items[0]);
        let local = items[1] ? repo.getColumn(items[1], true, true) : repo.primaryKeyColumn;
        let foreign = null;
        if (items[2]) {
            foreign = local === col ? f : local.foreign;
            if (!foreign)
                throw new RepoError(col.repository, "Kolumna " + items[2] + " nie posiada klucza obcego");
            foreign = foreign.repo.getColumn(items[2], true, true);
        }
        return [local, foreign];
    }

    Utils.forEach(value.constraints, obj => {

        const fc: ForeignConstraint = new ForeignConstraint();
        f.constraints.push(fc);

        Check.isArray(obj);

        Is.array(getColumn(obj[0]), a => {
            fc.currentLocal = a[0];
            fc.currentForeign = a[1];
        });

        Is.array(getColumn(obj[1]), a => {
            fc.allowedLocal = a[0];
            fc.allowedForeign = a[1];
        });
    });


    return f;
}